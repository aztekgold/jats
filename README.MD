# JATS v1.0.0 Specification
## JSON Agentic Table Standard

JATS (JSON Agentic Table Standard) is a robust, platform-agnostic, and AI-friendly format for structured data tables. It is designed to be the "HTML of Tables" for the agentic webâ€”readable by humans, optimized for machines, and portable across any environment.

---

## Table of Contents
1. [Introduction](#1-introduction)
2. [Design Philosophy](#2-design-philosophy)
3. [Unified ID Generation](#3-unified-id-generation)
4. [Schema Definition](#4-schema-definition)
    * [4.1 Columns](#41-columns)
    * [4.2 Views](#42-views)
    * [4.3 Rows](#43-rows)
    * [4.4 Metadata & Policy](#44-metadata--policy)
5. [Helper Logic](#5-helper-logic)

---

## 1. Introduction

As AI agents increasingly interact with structured data, the need for a standardized, clear, and deterministic table format has grown. JATS serves this need by providing a schema that includes semantic anchors (descriptions) for every field, a strict typing system, and a collision-resistant ID generation strategy that allows for distributed writing without coordination.

## 2. Design Philosophy

*   **Platform Agnostic:** Portable JSON structure that can live in a database, a local file, or an API response.
*   **Actor-Aware:** Explicit `allowAgent` policies define the machine's boundaries, ensuring safe interaction.
*   **Lexicographical Identity:** Unified ID generation logic ensures data is naturally sortable and unique without central counters.
*   **Semantic Anchor:** In-line descriptions provide "Decision Support" for AI Agents, allowing LLMs to understand the *meaning* of a column, not just its key.

---

## 3. Unified ID Generation

JATS uses **Crockford's Base32** alphabet (`0123456789ABCDEFGHJKMNPQRSTVWXYZ`) for all identifiers to ensure human readability and URL safety (excluding `I`, `L`, `O`, `U`).

### 2.1 Schema IDs (Prefix + 3 Random)
Short, stable handles for structural elements.
*   **Columns:** `col_` + 3 random chars (e.g., `col_X9Z`)
*   **Views:** `view_` + 3 random chars (e.g., `view_B2Y`)
*   **Filters:** `flt_` + 3 random chars (e.g., `flt_K5P`)

### 2.2 Row IDs (10 Time + 3 Random)
A 13-character string: `TTTTTTTTTTRRR`.
*   **Time (10 chars):** `Date.now()` encoded in Crockford's Base32.
*   **Random (3 chars):** Suffix generated by the same `random3Char()` utility.
*   **Logic:** This allow approx. 32 unique IDs per millisecond per node, ensuring perfect chronological sorting and collision resistance suitable for high-frequency agentic writes.

---

## 4. Schema Definition

The JATS schema is defined using TypeScript interfaces below, but is language-agnostic in practice.

### 4.1 Columns

Columns define the structure and constraints of the data.

```typescript
type JatsColumnType = 
  | "text" 
  | "number" 
  | "select" 
  | "date" 
  | "boolean" 
  | "url";

interface JatsOption {
  value: string;
  color?: string; // UI hint: "red", "#ff0000", etc.
}

interface JatsColumn {
  id: `col_${string}`;
  name: string;
  type: JatsColumnType;
  description?: string; // Context for Agents
  display: {
    width: number;
    dateFormat?: string; // Optional: UI format (e.g. "YYYY-MM-DD")
  };
  constraints?: {
    multiSelect?: boolean;
    options?: JatsOption[];
    required?: boolean;
    min?: number;
    max?: number;
    pattern?: string;
  };
}
```

### 4.2 Views

Views correspond to saved states of the table, including filtering, sorting, and visibility.

```typescript
interface JatsFilter {
  id: `flt_${string}`;
  columnId: string;
  operator: "is" | "isNot" | "contains" | "gt" | "lt" | "isEmpty" | "isNotEmpty";
  value: any;
}

interface JatsSort {
  columnId: string;
  direction: "asc" | "desc";
}

interface JatsView {
  id: `view_${string}`;
  name: string;
  description: string;
  filters: JatsFilter[];
  sorts: JatsSort[];
  hiddenColumns: string[];   // List of column IDs to hide
  columnOrder: string[];     // List of column IDs in display order
}
```

### 4.3 Rows

Rows store the actual data. Cells are keyed by Column ID, not component name, to allow renaming columns without breaking data.

```typescript
interface JatsRow {
  id: string; // 13 chars: 10 Time + 3 Random
  cells: Record<string, any>; // Keyed by col_id (e.g. "col_A1B": "Value")
}
```

### 4.4 Metadata & Policy

```typescript
interface JatsSchema {
  version: "1.0.0";
  metadata: {
    title: string;
    description: string;
  };
  policy: {
    permissions: {
      allowAgentRead: boolean;
      allowAgentCreate: boolean;
      allowAgentUpdate: boolean;
      allowAgentDelete: boolean;
    };
  };
  columns: JatsColumn[];
  views: JatsView[];
  rows: JatsRow[];
}
```

---

## 5. Helper Logic

Standardized logic for generating compliant IDs.

```typescript
const CROCKFORD_ALPHABET = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";

/**
 * Encodes a number into a Crockford Base32 string of a specific length.
 */
function encodeBase32(value: number, length: number): string {
  let result = "";
  let n = value;
  while (n > 0) {
    result = CROCKFORD_ALPHABET[n % 32] + result;
    n = Math.floor(n / 32);
  }
  return result.padStart(length, "0");
}

/**
 * Generates the unified 3-character random suffix.
 */
function random3Char(): string {
  let result = "";
  for (let i = 0; i < 3; i++) {
    const randomIndex = Math.floor(Math.random() * 32);
    result += CROCKFORD_ALPHABET[randomIndex];
  }
  return result;
}

/**
 * JATS Row ID: 10 Chars Time (Crockford) + 3 Chars Random
 */
export function generateRowId(): string {
  const timestamp = Date.now();
  return encodeBase32(timestamp, 10) + random3Char();
}

/**
 * JATS Schema IDs
 */
export const generateColId = () => `col_${random3Char()}`;
export const generateViewId = () => `view_${random3Char()}`;
export const generateFilterId = () => `flt_${random3Char()}`;
```
