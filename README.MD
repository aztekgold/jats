# JATS v1.0.0 Specification
## JSON Agentic Table Standard

JATS (JSON Agentic Table Standard) is a platform-agnostic, AI-first format for structured data tables. It embeds meaning, structure, and permissions directly into tables, allowing agents to safely read, write, and exchange data with minimal overhead. JATS is both human- and machine-readable, designed for clarity, longevity and portability.

---

## Table of Contents
1. [Introduction](#1-introduction)
2. [Design Philosophy](#2-design-philosophy)
3. [Unified ID Generation](#3-unified-id-generation)
4. [Schema Definition](#4-schema-definition)
    * [4.1 Columns](#41-columns)
    * [4.2 Views](#42-views)
    * [4.3 Rows](#43-rows)
    * [4.4 Metadata & Policy](#44-metadata--policy)
5. [Helper Logic](#5-helper-logic)

---

## 1. Introduction

AI agents can read tables, but they cannot reliably understand them. Formats like CSV, Markdown, and plain JSON store values but not meaning. They lack typing, context, identity, and safe interaction boundaries, forcing agents to guess what data represents and making joins unsafe, automation brittle, and reasoning error-prone.

JATS addresses this problem by providing a standardized, deterministic table schema with semantic anchors (field descriptions), a strict typing system, constraints, and a collision-resistant ID strategy. This enables distributed, multi-agent table writing without coordination, making structured data safer, clearer, and more reliable for both humans and AI.

## 2. Design Philosophy

*   **Platform Agnostic:** Portable JSON structure that can live in a database, a local file, or an API response.
*   **Actor-Aware:** Explicit `allowAgent` policies define the machine's boundaries, ensuring safe interaction.
*   **Sortable Unique ID:** Unified ID generation logic ensures data is naturally sortable and unique without central counters.
*   **Semantic Anchor:** In-line descriptions provide "Decision Support" for AI Agents, allowing LLMs to understand the *meaning* of a column, not just its key.

---

## 3. Unified ID Generation

JATS uses a **Base36** alphabet (`0123456789abcdefghijklmnopqrstuvwxyz`) for all identifiers to balance token friendly compression with naturally sortable, URL-friendly, and case-safe strings

### 3.1 Schema IDs (Prefix + 3 Random)
Short, stable handles for structural elements.
*   **Columns:** `col_` + 3 random chars (e.g., `col_x9z`)
*   **Views:** `view_` + 3 random chars (e.g., `view_b2y`)
*   **Filters:** `flt_` + 3 random chars (e.g., `flt_k5p`)

### 3.2 Row IDs (9 Time + 3 Random)
A 12-character string: `TTTTTTTTTRRR`.
*   **Time (9 chars):** `Date.now()` encoded in Base36.
*   **Random (3 chars):** Suffix generated by the same `random3Char()` utility.
*   **Logic:** This allows approx. 46 unique IDs per millisecond per node, ensuring perfect chronological sorting and collision resistance suitable for high-frequency agentic writes.

---

## 4. Schema Definition

The JATS schema is defined using TypeScript interfaces below, but is language-agnostic in practice.

### 4.1 Columns

Columns define the structure and constraints of the data.

```typescript
type JatsColumnType = 
  | "text" 
  | "number" 
  | "select" 
  | "date" 
  | "boolean" 
  | "url";

interface JatsOption {
  value: string;
  color?: string; // UI hint: "red", "#ff0000", etc.
}

interface JatsColumn {
  id: `col_${string}`;
  name: string;
  type: JatsColumnType;
  description?: string; // Context for Agents
  display: {
    width: number;
    dateFormat?: string; // Optional: UI format (e.g. "YYYY-MM-DD")
  };
  constraints?: {
    multiSelect?: boolean;
    options?: JatsOption[];
    required?: boolean;
    min?: number;
    max?: number;
    pattern?: string;
  };
}
```

### 4.2 Views

Views correspond to saved states of the table, including filtering, sorting, and visibility.

```typescript
interface JatsFilter {
  id: `flt_${string}`;
  columnId: string;
  operator: "is" | "isNot" | "contains" | "gt" | "lt" | "isEmpty" | "isNotEmpty";
  value: any;
}

interface JatsSort {
  columnId: string;
  direction: "asc" | "desc";
}

interface JatsView {
  id: `view_${string}`;
  name: string;
  description: string;
  filters: JatsFilter[];
  sorts: JatsSort[];
  hiddenColumns: string[];   // List of column IDs to hide
  columnOrder: string[];     // List of column IDs in display order
}
```

### 4.3 Rows

Rows store the actual data. Cells are keyed by Column ID, not component name, to allow renaming columns without breaking data.

```typescript
interface JatsRow {
  id: string; // 12 chars: 9 Time + 3 Random
  cells: Record<string, any>; // Keyed by col_id (e.g. "col_a1b": "Value")
}
```

### 4.4 Metadata & Policy

```typescript
interface JatsSchema {
  version: "1.0.0";
  metadata: {
    title: string;
    description: string;
  };
  policy: {
    permissions: {
      allowAgentRead: boolean;
      allowAgentCreate: boolean;
      allowAgentUpdate: boolean;
      allowAgentDelete: boolean;
    };
  };
  columns: JatsColumn[];
  views: JatsView[];
  rows: JatsRow[];
}
```

---

## 5. Helper Logic

Standardized logic for generating compliant IDs.

```typescript
const BASE36_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

/**
 * Encodes a number into a Base36 string of a specific length.
 */
function encodeBase36(value: number, length: number): string {
  let result = "";
  let n = value;
  while (n > 0) {
    result = BASE36_ALPHABET[n % 36] + result;
    n = Math.floor(n / 36);
  }
  return result.padStart(length, "0");
}

/**
 * Generates the unified 3-character random suffix.
 */
function random3Char(): string {
  let result = "";
  for (let i = 0; i < 3; i++) {
    const randomIndex = Math.floor(Math.random() * 36);
    result += BASE36_ALPHABET[randomIndex];
  }
  return result;
}

/**
 * JATS Row ID: 9 Chars Time (Base36) + 3 Chars Random
 */
export function generateRowId(): string {
  const timestamp = Date.now();
  return encodeBase36(timestamp, 9) + random3Char();
}

/**
 * JATS Schema IDs
 */
export const generateColId = () => `col_${random3Char()}`;
export const generateViewId = () => `view_${random3Char()}`;
export const generateFilterId = () => `flt_${random3Char()}`;
```

---

## 6. Agent Tooling Integrations (JATS Agent)

JATS provides native tooling features that allow backend systems to securely expose table operations directly to LLM agents. Features include:

*   **Native Zod Generation:** Dynamically builds precise parameter schemas strictly enforcing the `JatsColumn` settings and configurations of the current table.
*   **Unified Provider Wrapping:** Tool definitions are shaped generically and can be cleanly exported natively to Vercel AI SDK, OpenAI, and Anthropic formatting (`toVercel()`, `toOpenAI()`, and `toAnthropic()`).
*   **Granular Boundary Protection:** Execution logic explicitly checks schema policy capabilities (`allowAgentCreate`, `allowAgentUpdate`, etc.) before fulfilling agent operations to maintain sandbox integrity.

The supported dynamic schema tools include:
1.  **`add_row`**: Dynamically maps necessary column insertions against defined columns.
2.  **`update_row`**: Enforces a strictly validated `row_id` field alongside safely mapped optional updates for the respective columns.
3.  **`add_select_option`**: Allows agents to systematically establish new distinct classification constraints directly on categorized `select` columns.
